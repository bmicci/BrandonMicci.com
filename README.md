# BrandonMicci.com Deployment & Automation Guide

This repository hosts the BrandonMicci.com Next.js application. The project now ships with an end-to-end delivery workflow that
runs quality gates, deploys to Vercel, and can surface remediation guidance automatically when something goes wrong.

## Local Development

```bash
npm install
npm run dev
```

The local server runs on [http://localhost:3000](http://localhost:3000). Update files inside `src/` to iterate; the dev server
supports hot reloading. Before committing, run the same checks that GitHub Actions uses:

```bash
npm run lint -- --max-warnings=0
npm run build
```

## GitHub Actions CI/CD for Vercel

A reusable GitHub Actions workflow lives in [`.github/workflows/deploy.yml`](.github/workflows/deploy.yml). It executes on every
push or pull request to `main` and performs the following stages:

1. Installs dependencies with `npm ci` using the Node.js version defined in `.nvmrc`.
2. Runs ESLint with a zero-warning budget.
3. Builds the Next.js application to ensure production readiness.
4. (Optional) Pulls Vercel environment configuration and deploys via the Vercel CLI when deployment secrets are configured.
5. Uploads build/deploy logs and invokes the OpenAI API for actionable remediation tips whenever deployment fails.

### Required GitHub Secrets

Add the following secrets in your repository settings (`Settings ‚Ä∫ Secrets and variables ‚Ä∫ Actions`). They mirror the credentials
used for Vercel CLI automation. The deployment steps are skipped automatically when the secrets are missing, so you can
progressively roll out the CD portion.

| Secret | Description |
| ------ | ----------- |
| `VERCEL_TOKEN` | Personal or machine token from the Vercel dashboard with access to the project. |
| `VERCEL_ORG_ID` | Organization ID (copy from `.vercel/project.json` or the Vercel project settings). |
| `VERCEL_PROJECT_ID` | Project ID (also available in `.vercel/project.json`). |
| `OPENAI_API_KEY` | **Optional**. Enables AI-powered log analysis when deployments fail. |
| `OPENAI_MODEL` | **Optional** override (defaults to `gpt-4o-mini`). |

> üí° Keep your `.vercel/project.json` file out of source control. Populate the secrets above directly from the Vercel dashboard to
> avoid leaking credentials.

### What Happens on Failure?

When the deploy step fails, the workflow:

- Emits an inline `::error::` annotation in the Actions log.
- Uploads `vercel-build.log` and `vercel-deploy.log` as downloadable artifacts.
- Executes [`scripts/analyze-vercel-error.mjs`](scripts/analyze-vercel-error.mjs) to summarize root causes and propose fixes using
  OpenAI (if the API key is configured).

Use the artifacts to reproduce issues locally via `npx vercel build` or `vercel dev`. The AI summary is printed directly in the
workflow logs for quick triage.

## Connecting GitHub & Vercel

1. Visit your project in the [Vercel dashboard](https://vercel.com/dashboard) and open **Settings ‚Ä∫ Git**.
2. Link the BrandonMicci.com GitHub repository so Vercel automatically creates preview deployments for pull requests and promotes
   `main` to production.
3. Configure the same environment variables in both Vercel and GitHub Actions secrets to avoid mismatches.
4. (Optional) Enable [Vercel webhooks](https://vercel.com/docs/integrations/webhooks) if you want to trigger additional automation
   when deployments finish.

Preview URLs generated by Vercel appear in the Action logs (parsed from the CLI output) when deployments succeed.

## Using Cursor for AI-Assisted Development

Cursor pairs well with this workflow as an AI-first IDE:

- **Clone & Branch in Cursor:** Use the Source Control panel to clone the repo, create feature branches, and keep commits local
  until checks pass.
- **Composer Mode & Chat:** Ask Cursor to review components before you push. Example prompts:
  - ‚ÄúAudit this page for static export issues that might break on Vercel.‚Äù
  - ‚ÄúGenerate unit tests or lint fixes for this component.‚Äù
- **Tight Feedback Loop:** When a deployment fails, pull the latest logs from GitHub Actions or Vercel, paste them into Cursor‚Äôs
  chat, and iterate until the workflow passes locally.

By catching issues in Cursor and verifying with `npm run build`, you minimize red builds once the CI pipeline runs.

## Automating the Error Feedback Loop

The [`scripts/analyze-vercel-error.mjs`](scripts/analyze-vercel-error.mjs) helper powers the ‚ÄúAI-assisted log analysis‚Äù step in the
workflow. It:

1. Reads the captured Vercel CLI output (last 6,000 characters to stay within token limits).
2. Calls OpenAI‚Äôs Chat Completions API with a DevOps-tuned prompt.
3. Prints a concise summary plus recommended remediation steps back into the Actions log.

Customize it by adjusting the prompt, swapping in another model via the `OPENAI_MODEL` secret, or extending the script to open
GitHub issues automatically using the REST API.

## Troubleshooting Checklist

- **Environment variables:** Keep them synchronized between Vercel and GitHub Secrets‚Äîmost runtime crashes stem from mismatches.
- **Local verification:** Run `npx vercel dev` or `npx vercel build` locally using the same credentials when reproducing failures.
- **Monitoring:** Integrate providers like Sentry or Logflare to capture runtime errors, then feed those logs into the AI analysis
  script for richer feedback.
- **Progressive rollout:** Test new automation on a staging branch or GitHub Environment with required reviewers before merging to
  `main`.

With these practices in place, the pipeline catches regressions early, deployments stay reliable, and developers receive
immediate, actionable guidance when something goes wrong.
